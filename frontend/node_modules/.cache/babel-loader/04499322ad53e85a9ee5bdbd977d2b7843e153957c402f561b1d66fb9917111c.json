{"ast":null,"code":"/*!\r\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\n\nimport { Buffer } from 'buffer';\nimport { Sha256 } from '@aws-crypto/sha256-js';\nimport { Platform } from './Platform';\nimport BigInteger from './BigInteger';\nimport AuthenticationHelper from './AuthenticationHelper';\nimport CognitoAccessToken from './CognitoAccessToken';\nimport CognitoIdToken from './CognitoIdToken';\nimport CognitoRefreshToken from './CognitoRefreshToken';\nimport CognitoUserSession from './CognitoUserSession';\nimport DateHelper from './DateHelper';\nimport CognitoUserAttribute from './CognitoUserAttribute';\nimport StorageHelper from './StorageHelper';\n\n/**\r\n * @callback nodeCallback\r\n * @template T result\r\n * @param {*} err The operation failure reason, or null.\r\n * @param {T} result The operation result.\r\n */\n\n/**\r\n * @callback onFailure\r\n * @param {*} err Failure reason.\r\n */\n\n/**\r\n * @callback onSuccess\r\n * @template T result\r\n * @param {T} result The operation result.\r\n */\n\n/**\r\n * @callback mfaRequired\r\n * @param {*} details MFA challenge details.\r\n */\n\n/**\r\n * @callback customChallenge\r\n * @param {*} details Custom challenge details.\r\n */\n\n/**\r\n * @callback inputVerificationCode\r\n * @param {*} data Server response.\r\n */\n\n/**\r\n * @callback authSuccess\r\n * @param {CognitoUserSession} session The new session.\r\n * @param {bool=} userConfirmationNecessary User must be confirmed.\r\n */\n\nvar isNavigatorAvailable = typeof navigator !== 'undefined';\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? 'react-native' : navigator.userAgent : 'nodejs';\n\n/** @class */\nvar CognitoUser = /*#__PURE__*/function () {\n  /**\r\n   * Constructs a new CognitoUser object\r\n   * @param {object} data Creation options\r\n   * @param {string} data.Username The user's username.\r\n   * @param {CognitoUserPool} data.Pool Pool containing the user.\r\n   * @param {object} data.Storage Optional storage object.\r\n   */\n  function CognitoUser(data) {\n    if (data == null || data.Username == null || data.Pool == null) {\n      throw new Error('Username and Pool information are required.');\n    }\n    this.username = data.Username || '';\n    this.pool = data.Pool;\n    this.Session = null;\n    this.client = data.Pool.client;\n    this.signInUserSession = null;\n    this.authenticationFlowType = 'USER_SRP_AUTH';\n    this.storage = data.Storage || new StorageHelper().getStorage();\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\n  }\n\n  /**\r\n   * Sets the session for this user\r\n   * @param {CognitoUserSession} signInUserSession the session\r\n   * @returns {void}\r\n   */\n  var _proto = CognitoUser.prototype;\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\n    this.clearCachedUserData();\n    this.signInUserSession = signInUserSession;\n    this.cacheTokens();\n  }\n\n  /**\r\n   * @returns {CognitoUserSession} the current session for this user\r\n   */;\n  _proto.getSignInUserSession = function getSignInUserSession() {\n    return this.signInUserSession;\n  }\n\n  /**\r\n   * @returns {string} the user's username\r\n   */;\n  _proto.getUsername = function getUsername() {\n    return this.username;\n  }\n\n  /**\r\n   * @returns {String} the authentication flow type\r\n   */;\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\n    return this.authenticationFlowType;\n  }\n\n  /**\r\n   * sets authentication flow type\r\n   * @param {string} authenticationFlowType New value.\r\n   * @returns {void}\r\n   */;\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\n    this.authenticationFlowType = authenticationFlowType;\n  }\n\n  /**\r\n   * This is used for authenticating the user through the custom authentication flow.\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\n    var _this = this;\n    var authParameters = authDetails.getAuthParameters();\n    authParameters.USERNAME = this.username;\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'CUSTOM_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('InitiateAuth', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = data.ChallengeName;\n      var challengeParameters = data.ChallengeParameters;\n      if (challengeName === 'CUSTOM_CHALLENGE') {\n        _this.Session = data.Session;\n        return callback.customChallenge(challengeParameters);\n      }\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\n      _this.cacheTokens();\n      return callback.onSuccess(_this.signInUserSession);\n    });\n  }\n\n  /**\r\n   * This is used for authenticating the user.\r\n   * stuff\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {newPasswordRequired} callback.newPasswordRequired new\r\n   *        password and any required attributes are required to continue\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\n    if (this.authenticationFlowType === 'USER_PASSWORD_AUTH') {\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\n    } else if (this.authenticationFlowType === 'USER_SRP_AUTH' || this.authenticationFlowType === 'CUSTOM_AUTH') {\n      return this.authenticateUserDefaultAuth(authDetails, callback);\n    }\n    return callback.onFailure(new Error('Authentication flow type is invalid.'));\n  }\n\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * It calls the AuthenticationHelper for SRP related\r\n   * stuff\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {newPasswordRequired} callback.newPasswordRequired new\r\n   *        password and any required attributes are required to continue\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\n    var _this2 = this;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var dateHelper = new DateHelper();\n    var serverBValue;\n    var salt;\n    var authParameters = {};\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    authParameters.USERNAME = this.username;\n    authenticationHelper.getLargeAValue(function (errOnAValue, aValue) {\n      // getLargeAValue callback start\n      if (errOnAValue) {\n        callback.onFailure(errOnAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      if (_this2.authenticationFlowType === 'CUSTOM_AUTH') {\n        authParameters.CHALLENGE_NAME = 'SRP_A';\n      }\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n      var jsonReq = {\n        AuthFlow: _this2.authenticationFlowType,\n        ClientId: _this2.pool.getClientId(),\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetaData\n      };\n      if (_this2.getUserContextData(_this2.username)) {\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\n      }\n      _this2.client.request('InitiateAuth', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\n        serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        salt = new BigInteger(challengeParameters.SALT, 16);\n        _this2.getCachedDeviceKeyAndPassword();\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function (errOnHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errOnHkdf) {\n            callback.onFailure(errOnHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this2.pool.getUserPoolName(), 'utf8'), Buffer.from(_this2.username, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this2.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          if (_this2.deviceKey != null) {\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\n          }\n          var respondToAuthChallenge = function respondToAuthChallenge(challenge, challengeCallback) {\n            return _this2.client.request('RespondToAuthChallenge', challenge, function (errChallenge, dataChallenge) {\n              if (errChallenge && errChallenge.code === 'ResourceNotFoundException' && errChallenge.message.toLowerCase().indexOf('device') !== -1) {\n                challengeResponses.DEVICE_KEY = null;\n                _this2.deviceKey = null;\n                _this2.randomPassword = null;\n                _this2.deviceGroupKey = null;\n                _this2.clearCachedDeviceKeyAndPassword();\n                return respondToAuthChallenge(challenge, challengeCallback);\n              }\n              return challengeCallback(errChallenge, dataChallenge);\n            });\n          };\n          var jsonReqResp = {\n            ChallengeName: 'PASSWORD_VERIFIER',\n            ClientId: _this2.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session,\n            ClientMetadata: clientMetaData\n          };\n          if (_this2.getUserContextData()) {\n            jsonReqResp.UserContextData = _this2.getUserContextData();\n          }\n          respondToAuthChallenge(jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n          });\n          return undefined;\n          // getPasswordAuthenticationKey callback end\n        });\n\n        return undefined;\n      });\n      // getLargeAValue callback end\n    });\n  }\n\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\n    var _this3 = this;\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.PASSWORD = authDetails.getPassword();\n    if (!authParameters.PASSWORD) {\n      callback.onFailure(new Error('PASSWORD parameter is required'));\n      return;\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\n    var jsonReq = {\n      AuthFlow: 'USER_PASSWORD_AUTH',\n      ClientId: this.pool.getClientId(),\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetaData\n    };\n    if (this.getUserContextData(this.username)) {\n      jsonReq.UserContextData = this.getUserContextData(this.username);\n    }\n    // USER_PASSWORD_AUTH happens in a single round-trip: client sends userName and password,\n    // Cognito UserPools verifies password and returns tokens.\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\n    });\n  }\n\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * @param {object} dataAuthenticate authentication data\r\n   * @param {object} authenticationHelper helper created\r\n   * @param {callback} callback passed on from caller\r\n   * @returns {void}\r\n   */;\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\n    var _this4 = this;\n    var challengeName = dataAuthenticate.ChallengeName;\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\n    if (challengeName === 'SMS_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === 'SELECT_MFA_TYPE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.selectMFAType(challengeName, challengeParameters);\n    }\n    if (challengeName === 'MFA_SETUP') {\n      this.Session = dataAuthenticate.Session;\n      return callback.mfaSetup(challengeName, challengeParameters);\n    }\n    if (challengeName === 'SOFTWARE_TOKEN_MFA') {\n      this.Session = dataAuthenticate.Session;\n      return callback.totpRequired(challengeName, challengeParameters);\n    }\n    if (challengeName === 'CUSTOM_CHALLENGE') {\n      this.Session = dataAuthenticate.Session;\n      return callback.customChallenge(challengeParameters);\n    }\n    if (challengeName === 'NEW_PASSWORD_REQUIRED') {\n      this.Session = dataAuthenticate.Session;\n      var userAttributes = null;\n      var rawRequiredAttributes = null;\n      var requiredAttributes = [];\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n      if (challengeParameters) {\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\n      }\n      if (rawRequiredAttributes) {\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\n        }\n      }\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\n    }\n    if (challengeName === 'DEVICE_SRP_AUTH') {\n      this.Session = dataAuthenticate.Session;\n      this.getDeviceResponse(callback);\n      return undefined;\n    }\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n    this.challengeName = challengeName;\n    this.cacheTokens();\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\n    if (newDeviceMetadata == null) {\n      return callback.onSuccess(this.signInUserSession);\n    }\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n      if (errGenHash) {\n        return callback.onFailure(errGenHash);\n      }\n      var deviceSecretVerifierConfig = {\n        Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n        PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n      };\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\n      _this4.client.request('ConfirmDevice', {\n        DeviceKey: newDeviceMetadata.DeviceKey,\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n        DeviceName: userAgent\n      }, function (errConfirm, dataConfirm) {\n        if (errConfirm) {\n          return callback.onFailure(errConfirm);\n        }\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n        _this4.cacheDeviceKeyAndPassword();\n        if (dataConfirm.UserConfirmationNecessary === true) {\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\n        }\n        return callback.onSuccess(_this4.signInUserSession);\n      });\n      return undefined;\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This method is user to complete the NEW_PASSWORD_REQUIRED challenge.\r\n   * Pass the new password with any new user attributes to be updated.\r\n   * User attribute keys must be of format userAttributes.<attribute_name>.\r\n   * @param {string} newPassword new password for this user\r\n   * @param {object} requiredAttributeData map with values for all required attributes\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {mfaRequired} callback.mfaRequired MFA code required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *         response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\n    var _this5 = this;\n    if (!newPassword) {\n      return callback.onFailure(new Error('New password is required.'));\n    }\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\n    var finalUserAttributes = {};\n    if (requiredAttributeData) {\n      Object.keys(requiredAttributeData).forEach(function (key) {\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\n      });\n    }\n    finalUserAttributes.NEW_PASSWORD = newPassword;\n    finalUserAttributes.USERNAME = this.username;\n    var jsonReq = {\n      ChallengeName: 'NEW_PASSWORD_REQUIRED',\n      ClientId: this.pool.getClientId(),\n      ChallengeResponses: finalUserAttributes,\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (errAuthenticate, dataAuthenticate) {\n      if (errAuthenticate) {\n        return callback.onFailure(errAuthenticate);\n      }\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to get a session using device authentication. It is called at the end of user\r\n   * authentication\r\n   *\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   * @private\r\n   */;\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\n    var _this6 = this;\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\n    var dateHelper = new DateHelper();\n    var authParameters = {};\n    authParameters.USERNAME = this.username;\n    authParameters.DEVICE_KEY = this.deviceKey;\n    authenticationHelper.getLargeAValue(function (errAValue, aValue) {\n      // getLargeAValue callback start\n      if (errAValue) {\n        callback.onFailure(errAValue);\n      }\n      authParameters.SRP_A = aValue.toString(16);\n      var jsonReq = {\n        ChallengeName: 'DEVICE_SRP_AUTH',\n        ClientId: _this6.pool.getClientId(),\n        ChallengeResponses: authParameters,\n        ClientMetadata: clientMetadata,\n        Session: _this6.Session\n      };\n      if (_this6.getUserContextData()) {\n        jsonReq.UserContextData = _this6.getUserContextData();\n      }\n      _this6.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        var challengeParameters = data.ChallengeParameters;\n        var serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\n        var salt = new BigInteger(challengeParameters.SALT, 16);\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function (errHkdf, hkdf) {\n          // getPasswordAuthenticationKey callback start\n          if (errHkdf) {\n            return callback.onFailure(errHkdf);\n          }\n          var dateNow = dateHelper.getNowString();\n          var concatBuffer = Buffer.concat([Buffer.from(_this6.deviceGroupKey, 'utf8'), Buffer.from(_this6.deviceKey, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\n          var awsCryptoHash = new Sha256(hkdf);\n          awsCryptoHash.update(concatBuffer);\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\n          var challengeResponses = {};\n          challengeResponses.USERNAME = _this6.username;\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\n          challengeResponses.TIMESTAMP = dateNow;\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\n          var jsonReqResp = {\n            ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n            ClientId: _this6.pool.getClientId(),\n            ChallengeResponses: challengeResponses,\n            Session: data.Session\n          };\n          if (_this6.getUserContextData()) {\n            jsonReqResp.UserContextData = _this6.getUserContextData();\n          }\n          _this6.client.request('RespondToAuthChallenge', jsonReqResp, function (errAuthenticate, dataAuthenticate) {\n            if (errAuthenticate) {\n              return callback.onFailure(errAuthenticate);\n            }\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n            _this6.cacheTokens();\n            return callback.onSuccess(_this6.signInUserSession);\n          });\n          return undefined;\n          // getPasswordAuthenticationKey callback end\n        });\n\n        return undefined;\n      });\n      // getLargeAValue callback end\n    });\n  }\n\n  /**\r\n   * This is used for a certain user to confirm the registration by using a confirmation code\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {bool} forceAliasCreation Allow migrating from an existing email / phone number.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      ConfirmationCode: confirmationCode,\n      Username: this.username,\n      ForceAliasCreation: forceAliasCreation,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ConfirmSignUp', jsonReq, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n  }\n\n  /**\r\n   * This is used by the user once he has the responses to a custom challenge\r\n   * @param {string} answerChallenge The custom challenge answer.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {customChallenge} callback.customChallenge\r\n   *    Custom challenge response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\n    var _this7 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\n    this.getCachedDeviceKeyAndPassword();\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: 'CUSTOM_CHALLENGE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\n    });\n  }\n\n  /**\r\n   * This is used by the user once he has an MFA code\r\n   * @param {string} confirmationCode The MFA code entered by the user.\r\n   * @param {object} callback Result callback map.\r\n   * @param {string} mfaType The mfa we are replying to.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\n    var _this8 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\n    var mfaTypeSelection = mfaType || 'SMS_MFA';\n    if (mfaTypeSelection === 'SOFTWARE_TOKEN_MFA') {\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\n    }\n    if (this.deviceKey != null) {\n      challengeResponses.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ChallengeName: mfaTypeSelection,\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, dataAuthenticate) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      var challengeName = dataAuthenticate.ChallengeName;\n      if (challengeName === 'DEVICE_SRP_AUTH') {\n        _this8.getDeviceResponse(callback);\n        return undefined;\n      }\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\n      _this8.cacheTokens();\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\n        return callback.onSuccess(_this8.signInUserSession);\n      }\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\n        if (errGenHash) {\n          return callback.onFailure(errGenHash);\n        }\n        var deviceSecretVerifierConfig = {\n          Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\n          PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\n        };\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\n        _this8.client.request('ConfirmDevice', {\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\n          DeviceName: userAgent\n        }, function (errConfirm, dataConfirm) {\n          if (errConfirm) {\n            return callback.onFailure(errConfirm);\n          }\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\n          _this8.cacheDeviceKeyAndPassword();\n          if (dataConfirm.UserConfirmationNecessary === true) {\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\n          }\n          return callback.onSuccess(_this8.signInUserSession);\n        });\n        return undefined;\n      });\n      return undefined;\n    });\n  }\n\n  /**\r\n   * This is used by an authenticated user to change the current password\r\n   * @param {string} oldUserPassword The current password.\r\n   * @param {string} newUserPassword The requested new password.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('ChangePassword', {\n      PreviousPassword: oldUserPassword,\n      ProposedPassword: newUserPassword,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by an authenticated user to enable MFA for itself\r\n   * @deprecated\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.enableMFA = function enableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var mfaOptions = [];\n    var mfaEnabled = {\n      DeliveryMedium: 'SMS',\n      AttributeName: 'phone_number'\n    };\n    mfaOptions.push(mfaEnabled);\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by an authenticated user to enable MFA for itself\r\n   * @param {IMfaSettings} smsMfaSettings the sms mfa settings\r\n   * @param {IMFASettings} softwareTokenMfaSettings the software token mfa settings\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('SetUserMFAPreference', {\n      SMSMfaSettings: smsMfaSettings,\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by an authenticated user to disable MFA for itself\r\n   * @deprecated\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.disableMFA = function disableMFA(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var mfaOptions = [];\n    this.client.request('SetUserSettings', {\n      MFAOptions: mfaOptions,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by an authenticated user to delete itself\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\n    var _this9 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('DeleteUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      _this9.clearCachedUser();\n      return callback(null, 'SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * @typedef {CognitoUserAttribute | { Name:string, Value:string }} AttributeArg\r\n   */\n  /**\r\n   * This is used by an authenticated user to change a list of attributes\r\n   * @param {AttributeArg[]} attributes A list of the new user attributes.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\n    var _this10 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('UpdateUserAttributes', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      UserAttributes: attributes,\n      ClientMetadata: clientMetadata\n    }, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      // update cached user\n      return _this10.getUserData(function () {\n        return callback(null, 'SUCCESS', result);\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by an authenticated user to get a list of attributes\r\n   * @param {nodeCallback<CognitoUserAttribute[]>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.getUserAttributes = function getUserAttributes(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      var attributeList = [];\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\n        var attribute = {\n          Name: userData.UserAttributes[i].Name,\n          Value: userData.UserAttributes[i].Value\n        };\n        var userAttribute = new CognitoUserAttribute(attribute);\n        attributeList.push(userAttribute);\n      }\n      return callback(null, attributeList);\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This was previously used by an authenticated user to get MFAOptions,\r\n   * but no longer returns a meaningful response. Refer to the documentation for\r\n   * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\r\n   * @deprecated\r\n   * @param {nodeCallback<MFAOptions>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.getMFAOptions = function getMFAOptions(callback) {\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err, userData) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, userData.MFAOptions);\n    });\n    return undefined;\n  }\n\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\n  _proto.createGetUserRequest = function createGetUserRequest() {\n    return this.client.promisifyRequest('GetUser', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    });\n  }\n\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\n    var _this11 = this;\n    if (options === void 0) {\n      options = {};\n    }\n    // best effort, if not possible\n    return new Promise(function (resolve) {\n      var refresh = _this11.signInUserSession.getRefreshToken();\n      if (refresh && refresh.getToken()) {\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\r\n   * @typedef {Object} GetUserDataOptions\r\n   * @property {boolean} bypassCache - force getting data from Cognito service\r\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\r\n   */\n\n  /**\r\n   * This is used by an authenticated users to get the userData\r\n   * @param {nodeCallback<UserData>} callback Called on success or error.\r\n   * @param {GetUserDataOptions} params\r\n   * @returns {void}\r\n   */;\n  _proto.getUserData = function getUserData(callback, params) {\n    var _this12 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.clearCachedUserData();\n      return callback(new Error('User is not authenticated'), null);\n    }\n    var userData = this.getUserDataFromCache();\n    if (!userData) {\n      this.fetchUserData().then(function (data) {\n        callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    if (this.isFetchUserDataAndTokenRequired(params)) {\n      this.fetchUserData().then(function (data) {\n        return _this12.refreshSessionIfPossible(params).then(function () {\n          return data;\n        });\n      }).then(function (data) {\n        return callback(null, data);\n      })[\"catch\"](callback);\n      return;\n    }\n    try {\n      callback(null, JSON.parse(userData));\n      return;\n    } catch (err) {\n      this.clearCachedUserData();\n      callback(err, null);\n      return;\n    }\n  }\n\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\n    var userData = this.storage.getItem(this.userDataKey);\n    return userData;\n  }\n\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\n    var _ref = params || {},\n      _ref$bypassCache = _ref.bypassCache,\n      bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\n    return bypassCache;\n  }\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\n  _proto.fetchUserData = function fetchUserData() {\n    var _this13 = this;\n    return this.createGetUserRequest().then(function (data) {\n      _this13.cacheUserData(data);\n      return data;\n    });\n  }\n\n  /**\r\n   * This is used by an authenticated user to delete a list of attributes\r\n   * @param {string[]} attributeList Names of the attributes to delete.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\n    var _this14 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      return callback(new Error('User is not authenticated'), null);\n    }\n    this.client.request('DeleteUserAttributes', {\n      UserAttributeNames: attributeList,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n\n      // update cached user\n      return _this14.getUserData(function () {\n        return callback(null, 'SUCCESS');\n      }, {\n        bypassCache: true\n      });\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used by a user to resend a confirmation code\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    this.client.request('ResendConfirmationCode', jsonReq, function (err, result) {\n      if (err) {\n        return callback(err, null);\n      }\n      return callback(null, result);\n    });\n  }\n\n  /**\r\n   * @typedef {Object} GetSessionOptions\r\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\r\n   */\n\n  /**\r\n   * This is used to get a session, either from the session object\r\n   * or from  the local storage, or by using a refresh token\r\n   *\r\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\r\n   * @param {GetSessionOptions} options\r\n   * @returns {void}\r\n   */;\n  _proto.getSession = function getSession(callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (this.username == null) {\n      return callback(new Error('Username is null. Cannot retrieve a new session'), null);\n    }\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\n      return callback(null, this.signInUserSession);\n    }\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var idTokenKey = keyPrefix + \".idToken\";\n    var accessTokenKey = keyPrefix + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".clockDrift\";\n    if (this.storage.getItem(idTokenKey)) {\n      var idToken = new CognitoIdToken({\n        IdToken: this.storage.getItem(idTokenKey)\n      });\n      var accessToken = new CognitoAccessToken({\n        AccessToken: this.storage.getItem(accessTokenKey)\n      });\n      var refreshToken = new CognitoRefreshToken({\n        RefreshToken: this.storage.getItem(refreshTokenKey)\n      });\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\n      var sessionData = {\n        IdToken: idToken,\n        AccessToken: accessToken,\n        RefreshToken: refreshToken,\n        ClockDrift: clockDrift\n      };\n      var cachedSession = new CognitoUserSession(sessionData);\n      if (cachedSession.isValid()) {\n        this.signInUserSession = cachedSession;\n        return callback(null, this.signInUserSession);\n      }\n      if (!refreshToken.getToken()) {\n        return callback(new Error('Cannot retrieve a new session. Please authenticate.'), null);\n      }\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\n    } else {\n      callback(new Error('Local storage is missing an ID Token, Please authenticate'), null);\n    }\n    return undefined;\n  }\n\n  /**\r\n   * This uses the refreshToken to retrieve a new session\r\n   * @param {CognitoRefreshToken} refreshToken A previous session's refresh token.\r\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\n    var _this15 = this;\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\n    var authParameters = {};\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    if (this.storage.getItem(lastUserKey)) {\n      this.username = this.storage.getItem(lastUserKey);\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      authParameters.DEVICE_KEY = this.deviceKey;\n    }\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      AuthFlow: 'REFRESH_TOKEN_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\n      if (err) {\n        if (err.code === 'NotAuthorizedException') {\n          _this15.clearCachedUser();\n        }\n        return wrappedCallback(err, null);\n      }\n      if (authResult) {\n        var authenticationResult = authResult.AuthenticationResult;\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, 'RefreshToken')) {\n          authenticationResult.RefreshToken = refreshToken.getToken();\n        }\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\n        _this15.cacheTokens();\n        return wrappedCallback(null, _this15.signInUserSession);\n      }\n      return undefined;\n    });\n  }\n\n  /**\r\n   * This is used to save the session tokens to local storage\r\n   * @returns {void}\r\n   */;\n  _proto.cacheTokens = function cacheTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\n    this.storage.setItem(lastUserKey, this.username);\n  }\n\n  /**\r\n   * This is to cache user data\r\n   */;\n  _proto.cacheUserData = function cacheUserData(userData) {\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\n  }\n\n  /**\r\n   * This is to remove cached user data\r\n   */;\n  _proto.clearCachedUserData = function clearCachedUserData() {\n    this.storage.removeItem(this.userDataKey);\n  };\n  _proto.clearCachedUser = function clearCachedUser() {\n    this.clearCachedTokens();\n    this.clearCachedUserData();\n  }\n\n  /**\r\n   * This is used to cache the device key and device group and device password\r\n   * @returns {void}\r\n   */;\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\n  }\n\n  /**\r\n   * This is used to get current device key and device group and device password\r\n   * @returns {void}\r\n   */;\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    if (this.storage.getItem(deviceKeyKey)) {\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\n    }\n  }\n\n  /**\r\n   * This is used to clear the device key info from local storage\r\n   * @returns {void}\r\n   */;\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\n    this.storage.removeItem(deviceKeyKey);\n    this.storage.removeItem(randomPasswordKey);\n    this.storage.removeItem(deviceGroupKeyKey);\n  }\n\n  /**\r\n   * This is used to clear the session tokens from local storage\r\n   * @returns {void}\r\n   */;\n  _proto.clearCachedTokens = function clearCachedTokens() {\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\n    this.storage.removeItem(idTokenKey);\n    this.storage.removeItem(accessTokenKey);\n    this.storage.removeItem(refreshTokenKey);\n    this.storage.removeItem(lastUserKey);\n    this.storage.removeItem(clockDriftKey);\n  }\n\n  /**\r\n   * This is used to build a user session from tokens retrieved in the authentication result\r\n   * @param {object} authResult Successful auth response from server.\r\n   * @returns {CognitoUserSession} The new user session.\r\n   * @private\r\n   */;\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\n    var idToken = new CognitoIdToken(authResult);\n    var accessToken = new CognitoAccessToken(authResult);\n    var refreshToken = new CognitoRefreshToken(authResult);\n    var sessionData = {\n      IdToken: idToken,\n      AccessToken: accessToken,\n      RefreshToken: refreshToken\n    };\n    return new CognitoUserSession(sessionData);\n  }\n\n  /**\r\n   * This is used to initiate a forgot password request\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {inputVerificationCode?} callback.inputVerificationCode\r\n   *    Optional callback raised instead of onSuccess with response data.\r\n   * @param {onSuccess} callback.onSuccess Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ForgotPassword', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess(data);\n    });\n  }\n\n  /**\r\n   * This is used to confirm a new password using a confirmationCode\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {string} newPassword Confirm new password.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<void>} callback.onSuccess Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\n    var jsonReq = {\n      ClientId: this.pool.getClientId(),\n      Username: this.username,\n      ConfirmationCode: confirmationCode,\n      Password: newPassword,\n      ClientMetadata: clientMetadata\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('ConfirmForgotPassword', jsonReq, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n  }\n\n  /**\r\n   * This is used to initiate an attribute confirmation request\r\n   * @param {string} attributeName User attribute that needs confirmation.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {inputVerificationCode} callback.inputVerificationCode Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GetUserAttributeVerificationCode', {\n      AttributeName: attributeName,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      ClientMetadata: clientMetadata\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      if (typeof callback.inputVerificationCode === 'function') {\n        return callback.inputVerificationCode(data);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to confirm an attribute using a confirmation code\r\n   * @param {string} attributeName Attribute being confirmed.\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('VerifyUserAttribute', {\n      AttributeName: attributeName,\n      Code: confirmationCode,\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to get the device information using the current device key\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device data.\r\n   * @returns {void}\r\n   */;\n  _proto.getDevice = function getDevice(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey\n    }, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to forget a specific device\r\n   * @param {string} deviceKey Device key.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('ForgetDevice', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: deviceKey\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to forget the current device\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.forgetDevice = function forgetDevice(callback) {\n    var _this16 = this;\n    this.forgetSpecificDevice(this.deviceKey, {\n      onFailure: callback.onFailure,\n      onSuccess: function onSuccess(result) {\n        _this16.deviceKey = null;\n        _this16.deviceGroupKey = null;\n        _this16.randomPassword = null;\n        _this16.clearCachedDeviceKeyAndPassword();\n        return callback.onSuccess(result);\n      }\n    });\n  }\n\n  /**\r\n   * This is used to set the device status as remembered\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to set the device status as not remembered\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('UpdateDeviceStatus', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      DeviceKey: this.deviceKey,\n      DeviceRememberedStatus: 'not_remembered'\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to list all devices for a user\r\n   *\r\n   * @param {int} limit the number of devices returned in a call\r\n   * @param {string | null} paginationToken the pagination token in case any was returned before\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device list.\r\n   * @returns {void}\r\n   */;\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    var requestParams = {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n      Limit: limit\n    };\n    if (paginationToken) {\n      requestParams.PaginationToken = paginationToken;\n    }\n    this.client.request('ListDevices', requestParams, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      return callback.onSuccess(data);\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used to globally revoke all tokens issued to a user\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\n  _proto.globalSignOut = function globalSignOut(callback) {\n    var _this17 = this;\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\n      return callback.onFailure(new Error('User is not authenticated'));\n    }\n    this.client.request('GlobalSignOut', {\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n    }, function (err) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this17.clearCachedUser();\n      return callback.onSuccess('SUCCESS');\n    });\n    return undefined;\n  }\n\n  /**\r\n   * This is used for the user to signOut of the application and clear the cached tokens.\r\n   * @returns {void}\r\n   */;\n  _proto.signOut = function signOut(revokeTokenCallback) {\n    var _this18 = this;\n    // If tokens won't be revoked, we just clean the client data.\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== 'function') {\n      this.cleanClientData();\n      return;\n    }\n    this.getSession(function (error, _session) {\n      if (error) {\n        return revokeTokenCallback(error);\n      }\n      _this18.revokeTokens(function (err) {\n        _this18.cleanClientData();\n        revokeTokenCallback(err);\n      });\n    });\n  };\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\n    if (revokeTokenCallback === void 0) {\n      revokeTokenCallback = function revokeTokenCallback() {};\n    }\n    if (typeof revokeTokenCallback !== 'function') {\n      throw new Error('Invalid revokeTokenCallback. It should be a function.');\n    }\n    var tokensToBeRevoked = [];\n    if (!this.signInUserSession) {\n      var error = new Error('User is not authenticated');\n      return revokeTokenCallback(error);\n    }\n    if (!this.signInUserSession.getAccessToken()) {\n      var _error = new Error('No Access token available');\n      return revokeTokenCallback(_error);\n    }\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\n    var accessToken = this.signInUserSession.getAccessToken();\n    if (this.isSessionRevocable(accessToken)) {\n      if (refreshToken) {\n        return this.revokeToken({\n          token: refreshToken,\n          callback: revokeTokenCallback\n        });\n      }\n    }\n    revokeTokenCallback();\n  };\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\n    if (token && typeof token.decodePayload === 'function') {\n      try {\n        var _token$decodePayload = token.decodePayload(),\n          origin_jti = _token$decodePayload.origin_jti;\n        return !!origin_jti;\n      } catch (err) {\n        // Nothing to do, token doesnt have origin_jti claim\n      }\n    }\n    return false;\n  };\n  _proto.cleanClientData = function cleanClientData() {\n    this.signInUserSession = null;\n    this.clearCachedUser();\n  };\n  _proto.revokeToken = function revokeToken(_ref2) {\n    var token = _ref2.token,\n      callback = _ref2.callback;\n    this.client.requestWithRetry('RevokeToken', {\n      Token: token,\n      ClientId: this.pool.getClientId()\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      callback();\n    });\n  }\n\n  /**\r\n   * This is used by a user trying to select a given MFA\r\n   * @param {string} answerChallenge the mfa the user wants\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\n    var _this19 = this;\n    var challengeResponses = {};\n    challengeResponses.USERNAME = this.username;\n    challengeResponses.ANSWER = answerChallenge;\n    var jsonReq = {\n      ChallengeName: 'SELECT_MFA_TYPE',\n      ChallengeResponses: challengeResponses,\n      ClientId: this.pool.getClientId(),\n      Session: this.Session\n    };\n    if (this.getUserContextData()) {\n      jsonReq.UserContextData = this.getUserContextData();\n    }\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\n      if (err) {\n        return callback.onFailure(err);\n      }\n      _this19.Session = data.Session;\n      if (answerChallenge === 'SMS_MFA') {\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      if (answerChallenge === 'SOFTWARE_TOKEN_MFA') {\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\n      }\n      return undefined;\n    });\n  }\n\n  /**\r\n   * This returns the user context data for advanced security feature.\r\n   * @returns {string} the user context data from CognitoUserPool\r\n   */;\n  _proto.getUserContextData = function getUserContextData() {\n    var pool = this.pool;\n    return pool.getUserContextData(this.username);\n  }\n\n  /**\r\n   * This is used by an authenticated or a user trying to authenticate to associate a TOTP MFA\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\n    var _this20 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('AssociateSoftwareToken', {\n        Session: this.Session\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this20.Session = data.Session;\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    } else {\n      this.client.request('AssociateSoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.associateSecretCode(data.SecretCode);\n      });\n    }\n  }\n\n  /**\r\n   * This is used by an authenticated or a user trying to authenticate to verify a TOTP MFA\r\n   * @param {string} totpCode The MFA code entered by the user.\r\n   * @param {string} friendlyDeviceName The device name we are assigning to the device.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\n    var _this21 = this;\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\n      this.client.request('VerifySoftwareToken', {\n        Session: this.Session,\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        _this21.Session = data.Session;\n        var challengeResponses = {};\n        challengeResponses.USERNAME = _this21.username;\n        var jsonReq = {\n          ChallengeName: 'MFA_SETUP',\n          ClientId: _this21.pool.getClientId(),\n          ChallengeResponses: challengeResponses,\n          Session: _this21.Session\n        };\n        if (_this21.getUserContextData()) {\n          jsonReq.UserContextData = _this21.getUserContextData();\n        }\n        _this21.client.request('RespondToAuthChallenge', jsonReq, function (errRespond, dataRespond) {\n          if (errRespond) {\n            return callback.onFailure(errRespond);\n          }\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\n          _this21.cacheTokens();\n          return callback.onSuccess(_this21.signInUserSession);\n        });\n        return undefined;\n      });\n    } else {\n      this.client.request('VerifySoftwareToken', {\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\n        UserCode: totpCode,\n        FriendlyDeviceName: friendlyDeviceName\n      }, function (err, data) {\n        if (err) {\n          return callback.onFailure(err);\n        }\n        return callback.onSuccess(data);\n      });\n    }\n  };\n  return CognitoUser;\n}();\nexport { CognitoUser as default };","map":{"version":3,"names":["Buffer","Sha256","Platform","BigInteger","AuthenticationHelper","CognitoAccessToken","CognitoIdToken","CognitoRefreshToken","CognitoUserSession","DateHelper","CognitoUserAttribute","StorageHelper","isNavigatorAvailable","navigator","userAgent","isReactNative","CognitoUser","data","Username","Pool","Error","username","pool","Session","client","signInUserSession","authenticationFlowType","storage","Storage","getStorage","keyPrefix","getClientId","userDataKey","_proto","prototype","setSignInUserSession","clearCachedUserData","cacheTokens","getSignInUserSession","getUsername","getAuthenticationFlowType","setAuthenticationFlowType","initiateAuth","authDetails","callback","_this","authParameters","getAuthParameters","USERNAME","clientMetaData","Object","keys","getValidationData","length","getClientMetadata","jsonReq","AuthFlow","ClientId","AuthParameters","ClientMetadata","getUserContextData","UserContextData","request","err","onFailure","challengeName","ChallengeName","challengeParameters","ChallengeParameters","customChallenge","getCognitoUserSession","AuthenticationResult","onSuccess","authenticateUser","authenticateUserPlainUsernamePassword","authenticateUserDefaultAuth","_this2","authenticationHelper","getUserPoolName","dateHelper","serverBValue","salt","deviceKey","DEVICE_KEY","getLargeAValue","errOnAValue","aValue","SRP_A","toString","CHALLENGE_NAME","USER_ID_FOR_SRP","SRP_B","SALT","getCachedDeviceKeyAndPassword","getPasswordAuthenticationKey","getPassword","errOnHkdf","hkdf","dateNow","getNowString","concatBuffer","concat","from","SECRET_BLOCK","awsCryptoHash","update","resultFromAWSCrypto","digestSync","signatureString","challengeResponses","PASSWORD_CLAIM_SECRET_BLOCK","TIMESTAMP","PASSWORD_CLAIM_SIGNATURE","respondToAuthChallenge","challenge","challengeCallback","errChallenge","dataChallenge","code","message","toLowerCase","indexOf","randomPassword","deviceGroupKey","clearCachedDeviceKeyAndPassword","jsonReqResp","ChallengeResponses","errAuthenticate","dataAuthenticate","authenticateUserInternal","undefined","_this3","PASSWORD","authResult","_this4","mfaRequired","selectMFAType","mfaSetup","totpRequired","userAttributes","rawRequiredAttributes","requiredAttributes","userAttributesPrefix","getNewPasswordRequiredChallengeUserAttributePrefix","JSON","parse","i","substr","newPasswordRequired","getDeviceResponse","newDeviceMetadata","NewDeviceMetadata","generateHashDevice","DeviceGroupKey","DeviceKey","errGenHash","deviceSecretVerifierConfig","Salt","getSaltDevices","PasswordVerifier","getVerifierDevices","verifierDevices","getRandomPassword","AccessToken","getAccessToken","getJwtToken","DeviceSecretVerifierConfig","DeviceName","errConfirm","dataConfirm","cacheDeviceKeyAndPassword","UserConfirmationNecessary","completeNewPasswordChallenge","newPassword","requiredAttributeData","clientMetadata","_this5","finalUserAttributes","forEach","key","NEW_PASSWORD","_this6","errAValue","errHkdf","confirmRegistration","confirmationCode","forceAliasCreation","ConfirmationCode","ForceAliasCreation","sendCustomChallengeAnswer","answerChallenge","_this7","ANSWER","sendMFACode","mfaType","_this8","SMS_MFA_CODE","mfaTypeSelection","SOFTWARE_TOKEN_MFA_CODE","changePassword","oldUserPassword","newUserPassword","isValid","PreviousPassword","ProposedPassword","enableMFA","mfaOptions","mfaEnabled","DeliveryMedium","AttributeName","push","MFAOptions","setUserMfaPreference","smsMfaSettings","softwareTokenMfaSettings","SMSMfaSettings","SoftwareTokenMfaSettings","disableMFA","deleteUser","_this9","clearCachedUser","updateAttributes","attributes","_this10","UserAttributes","result","getUserData","bypassCache","getUserAttributes","userData","attributeList","attribute","Name","Value","userAttribute","getMFAOptions","createGetUserRequest","promisifyRequest","refreshSessionIfPossible","options","_this11","Promise","resolve","refresh","getRefreshToken","getToken","refreshSession","params","_this12","getUserDataFromCache","fetchUserData","then","isFetchUserDataAndTokenRequired","getItem","_ref","_ref$bypassCache","_this13","cacheUserData","deleteAttributes","_this14","UserAttributeNames","resendConfirmationCode","getSession","idTokenKey","accessTokenKey","refreshTokenKey","clockDriftKey","idToken","IdToken","accessToken","refreshToken","RefreshToken","clockDrift","parseInt","sessionData","ClockDrift","cachedSession","_this15","wrappedCallback","wrapRefreshSessionCallback","REFRESH_TOKEN","lastUserKey","deviceKeyKey","authenticationResult","hasOwnProperty","call","setItem","getIdToken","getClockDrift","stringify","removeItem","clearCachedTokens","randomPasswordKey","deviceGroupKeyKey","forgotPassword","inputVerificationCode","confirmPassword","Password","getAttributeVerificationCode","attributeName","verifyAttribute","Code","getDevice","forgetSpecificDevice","forgetDevice","_this16","setDeviceStatusRemembered","DeviceRememberedStatus","setDeviceStatusNotRemembered","listDevices","limit","paginationToken","requestParams","Limit","PaginationToken","globalSignOut","_this17","signOut","revokeTokenCallback","_this18","cleanClientData","error","_session","revokeTokens","tokensToBeRevoked","_error","isSessionRevocable","revokeToken","token","decodePayload","_token$decodePayload","origin_jti","_ref2","requestWithRetry","Token","sendMFASelectionAnswer","_this19","associateSoftwareToken","_this20","associateSecretCode","SecretCode","verifySoftwareToken","totpCode","friendlyDeviceName","_this21","UserCode","FriendlyDeviceName","errRespond","dataRespond","default"],"sources":["C:/Users/antho/Documents/College (Post-Secondary)/Grade 16 - 8th Semester/CSCI 499/Project/CS499_Capstone_Repository/frontend/node_modules/amazon-cognito-identity-js/es/CognitoUser.js"],"sourcesContent":["/*!\r\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport { Buffer } from 'buffer';\r\nimport { Sha256 } from '@aws-crypto/sha256-js';\r\nimport { Platform } from './Platform';\r\nimport BigInteger from './BigInteger';\r\nimport AuthenticationHelper from './AuthenticationHelper';\r\nimport CognitoAccessToken from './CognitoAccessToken';\r\nimport CognitoIdToken from './CognitoIdToken';\r\nimport CognitoRefreshToken from './CognitoRefreshToken';\r\nimport CognitoUserSession from './CognitoUserSession';\r\nimport DateHelper from './DateHelper';\r\nimport CognitoUserAttribute from './CognitoUserAttribute';\r\nimport StorageHelper from './StorageHelper';\r\n\r\n/**\r\n * @callback nodeCallback\r\n * @template T result\r\n * @param {*} err The operation failure reason, or null.\r\n * @param {T} result The operation result.\r\n */\r\n\r\n/**\r\n * @callback onFailure\r\n * @param {*} err Failure reason.\r\n */\r\n\r\n/**\r\n * @callback onSuccess\r\n * @template T result\r\n * @param {T} result The operation result.\r\n */\r\n\r\n/**\r\n * @callback mfaRequired\r\n * @param {*} details MFA challenge details.\r\n */\r\n\r\n/**\r\n * @callback customChallenge\r\n * @param {*} details Custom challenge details.\r\n */\r\n\r\n/**\r\n * @callback inputVerificationCode\r\n * @param {*} data Server response.\r\n */\r\n\r\n/**\r\n * @callback authSuccess\r\n * @param {CognitoUserSession} session The new session.\r\n * @param {bool=} userConfirmationNecessary User must be confirmed.\r\n */\r\n\r\nvar isNavigatorAvailable = typeof navigator !== 'undefined';\r\nvar userAgent = isNavigatorAvailable ? Platform.isReactNative ? 'react-native' : navigator.userAgent : 'nodejs';\r\n\r\n/** @class */\r\nvar CognitoUser = /*#__PURE__*/function () {\r\n  /**\r\n   * Constructs a new CognitoUser object\r\n   * @param {object} data Creation options\r\n   * @param {string} data.Username The user's username.\r\n   * @param {CognitoUserPool} data.Pool Pool containing the user.\r\n   * @param {object} data.Storage Optional storage object.\r\n   */\r\n  function CognitoUser(data) {\r\n    if (data == null || data.Username == null || data.Pool == null) {\r\n      throw new Error('Username and Pool information are required.');\r\n    }\r\n    this.username = data.Username || '';\r\n    this.pool = data.Pool;\r\n    this.Session = null;\r\n    this.client = data.Pool.client;\r\n    this.signInUserSession = null;\r\n    this.authenticationFlowType = 'USER_SRP_AUTH';\r\n    this.storage = data.Storage || new StorageHelper().getStorage();\r\n    this.keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\r\n    this.userDataKey = this.keyPrefix + \".\" + this.username + \".userData\";\r\n  }\r\n\r\n  /**\r\n   * Sets the session for this user\r\n   * @param {CognitoUserSession} signInUserSession the session\r\n   * @returns {void}\r\n   */\r\n  var _proto = CognitoUser.prototype;\r\n  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {\r\n    this.clearCachedUserData();\r\n    this.signInUserSession = signInUserSession;\r\n    this.cacheTokens();\r\n  }\r\n\r\n  /**\r\n   * @returns {CognitoUserSession} the current session for this user\r\n   */;\r\n  _proto.getSignInUserSession = function getSignInUserSession() {\r\n    return this.signInUserSession;\r\n  }\r\n\r\n  /**\r\n   * @returns {string} the user's username\r\n   */;\r\n  _proto.getUsername = function getUsername() {\r\n    return this.username;\r\n  }\r\n\r\n  /**\r\n   * @returns {String} the authentication flow type\r\n   */;\r\n  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {\r\n    return this.authenticationFlowType;\r\n  }\r\n\r\n  /**\r\n   * sets authentication flow type\r\n   * @param {string} authenticationFlowType New value.\r\n   * @returns {void}\r\n   */;\r\n  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {\r\n    this.authenticationFlowType = authenticationFlowType;\r\n  }\r\n\r\n  /**\r\n   * This is used for authenticating the user through the custom authentication flow.\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\r\n  _proto.initiateAuth = function initiateAuth(authDetails, callback) {\r\n    var _this = this;\r\n    var authParameters = authDetails.getAuthParameters();\r\n    authParameters.USERNAME = this.username;\r\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\r\n    var jsonReq = {\r\n      AuthFlow: 'CUSTOM_AUTH',\r\n      ClientId: this.pool.getClientId(),\r\n      AuthParameters: authParameters,\r\n      ClientMetadata: clientMetaData\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('InitiateAuth', jsonReq, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      var challengeName = data.ChallengeName;\r\n      var challengeParameters = data.ChallengeParameters;\r\n      if (challengeName === 'CUSTOM_CHALLENGE') {\r\n        _this.Session = data.Session;\r\n        return callback.customChallenge(challengeParameters);\r\n      }\r\n      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);\r\n      _this.cacheTokens();\r\n      return callback.onSuccess(_this.signInUserSession);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used for authenticating the user.\r\n   * stuff\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {newPasswordRequired} callback.newPasswordRequired new\r\n   *        password and any required attributes are required to continue\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\r\n  _proto.authenticateUser = function authenticateUser(authDetails, callback) {\r\n    if (this.authenticationFlowType === 'USER_PASSWORD_AUTH') {\r\n      return this.authenticateUserPlainUsernamePassword(authDetails, callback);\r\n    } else if (this.authenticationFlowType === 'USER_SRP_AUTH' || this.authenticationFlowType === 'CUSTOM_AUTH') {\r\n      return this.authenticateUserDefaultAuth(authDetails, callback);\r\n    }\r\n    return callback.onFailure(new Error('Authentication flow type is invalid.'));\r\n  }\r\n\r\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * It calls the AuthenticationHelper for SRP related\r\n   * stuff\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {newPasswordRequired} callback.newPasswordRequired new\r\n   *        password and any required attributes are required to continue\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *        response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\r\n  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {\r\n    var _this2 = this;\r\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\r\n    var dateHelper = new DateHelper();\r\n    var serverBValue;\r\n    var salt;\r\n    var authParameters = {};\r\n    if (this.deviceKey != null) {\r\n      authParameters.DEVICE_KEY = this.deviceKey;\r\n    }\r\n    authParameters.USERNAME = this.username;\r\n    authenticationHelper.getLargeAValue(function (errOnAValue, aValue) {\r\n      // getLargeAValue callback start\r\n      if (errOnAValue) {\r\n        callback.onFailure(errOnAValue);\r\n      }\r\n      authParameters.SRP_A = aValue.toString(16);\r\n      if (_this2.authenticationFlowType === 'CUSTOM_AUTH') {\r\n        authParameters.CHALLENGE_NAME = 'SRP_A';\r\n      }\r\n      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\r\n      var jsonReq = {\r\n        AuthFlow: _this2.authenticationFlowType,\r\n        ClientId: _this2.pool.getClientId(),\r\n        AuthParameters: authParameters,\r\n        ClientMetadata: clientMetaData\r\n      };\r\n      if (_this2.getUserContextData(_this2.username)) {\r\n        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);\r\n      }\r\n      _this2.client.request('InitiateAuth', jsonReq, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        var challengeParameters = data.ChallengeParameters;\r\n        _this2.username = challengeParameters.USER_ID_FOR_SRP;\r\n        _this2.userDataKey = _this2.keyPrefix + \".\" + _this2.username + \".userData\";\r\n        serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\r\n        salt = new BigInteger(challengeParameters.SALT, 16);\r\n        _this2.getCachedDeviceKeyAndPassword();\r\n        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function (errOnHkdf, hkdf) {\r\n          // getPasswordAuthenticationKey callback start\r\n          if (errOnHkdf) {\r\n            callback.onFailure(errOnHkdf);\r\n          }\r\n          var dateNow = dateHelper.getNowString();\r\n          var concatBuffer = Buffer.concat([Buffer.from(_this2.pool.getUserPoolName(), 'utf8'), Buffer.from(_this2.username, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\r\n          var awsCryptoHash = new Sha256(hkdf);\r\n          awsCryptoHash.update(concatBuffer);\r\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\r\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\r\n          var challengeResponses = {};\r\n          challengeResponses.USERNAME = _this2.username;\r\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\r\n          challengeResponses.TIMESTAMP = dateNow;\r\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\r\n          if (_this2.deviceKey != null) {\r\n            challengeResponses.DEVICE_KEY = _this2.deviceKey;\r\n          }\r\n          var respondToAuthChallenge = function respondToAuthChallenge(challenge, challengeCallback) {\r\n            return _this2.client.request('RespondToAuthChallenge', challenge, function (errChallenge, dataChallenge) {\r\n              if (errChallenge && errChallenge.code === 'ResourceNotFoundException' && errChallenge.message.toLowerCase().indexOf('device') !== -1) {\r\n                challengeResponses.DEVICE_KEY = null;\r\n                _this2.deviceKey = null;\r\n                _this2.randomPassword = null;\r\n                _this2.deviceGroupKey = null;\r\n                _this2.clearCachedDeviceKeyAndPassword();\r\n                return respondToAuthChallenge(challenge, challengeCallback);\r\n              }\r\n              return challengeCallback(errChallenge, dataChallenge);\r\n            });\r\n          };\r\n          var jsonReqResp = {\r\n            ChallengeName: 'PASSWORD_VERIFIER',\r\n            ClientId: _this2.pool.getClientId(),\r\n            ChallengeResponses: challengeResponses,\r\n            Session: data.Session,\r\n            ClientMetadata: clientMetaData\r\n          };\r\n          if (_this2.getUserContextData()) {\r\n            jsonReqResp.UserContextData = _this2.getUserContextData();\r\n          }\r\n          respondToAuthChallenge(jsonReqResp, function (errAuthenticate, dataAuthenticate) {\r\n            if (errAuthenticate) {\r\n              return callback.onFailure(errAuthenticate);\r\n            }\r\n            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\r\n          });\r\n          return undefined;\r\n          // getPasswordAuthenticationKey callback end\r\n        });\r\n\r\n        return undefined;\r\n      });\r\n      // getLargeAValue callback end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * @param {AuthenticationDetails} authDetails Contains the authentication data.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {mfaRequired} callback.mfaRequired MFA code\r\n   *        required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @returns {void}\r\n   */;\r\n  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {\r\n    var _this3 = this;\r\n    var authParameters = {};\r\n    authParameters.USERNAME = this.username;\r\n    authParameters.PASSWORD = authDetails.getPassword();\r\n    if (!authParameters.PASSWORD) {\r\n      callback.onFailure(new Error('PASSWORD parameter is required'));\r\n      return;\r\n    }\r\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\r\n    this.getCachedDeviceKeyAndPassword();\r\n    if (this.deviceKey != null) {\r\n      authParameters.DEVICE_KEY = this.deviceKey;\r\n    }\r\n    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();\r\n    var jsonReq = {\r\n      AuthFlow: 'USER_PASSWORD_AUTH',\r\n      ClientId: this.pool.getClientId(),\r\n      AuthParameters: authParameters,\r\n      ClientMetadata: clientMetaData\r\n    };\r\n    if (this.getUserContextData(this.username)) {\r\n      jsonReq.UserContextData = this.getUserContextData(this.username);\r\n    }\r\n    // USER_PASSWORD_AUTH happens in a single round-trip: client sends userName and password,\r\n    // Cognito UserPools verifies password and returns tokens.\r\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   * @param {object} dataAuthenticate authentication data\r\n   * @param {object} authenticationHelper helper created\r\n   * @param {callback} callback passed on from caller\r\n   * @returns {void}\r\n   */;\r\n  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {\r\n    var _this4 = this;\r\n    var challengeName = dataAuthenticate.ChallengeName;\r\n    var challengeParameters = dataAuthenticate.ChallengeParameters;\r\n    if (challengeName === 'SMS_MFA') {\r\n      this.Session = dataAuthenticate.Session;\r\n      return callback.mfaRequired(challengeName, challengeParameters);\r\n    }\r\n    if (challengeName === 'SELECT_MFA_TYPE') {\r\n      this.Session = dataAuthenticate.Session;\r\n      return callback.selectMFAType(challengeName, challengeParameters);\r\n    }\r\n    if (challengeName === 'MFA_SETUP') {\r\n      this.Session = dataAuthenticate.Session;\r\n      return callback.mfaSetup(challengeName, challengeParameters);\r\n    }\r\n    if (challengeName === 'SOFTWARE_TOKEN_MFA') {\r\n      this.Session = dataAuthenticate.Session;\r\n      return callback.totpRequired(challengeName, challengeParameters);\r\n    }\r\n    if (challengeName === 'CUSTOM_CHALLENGE') {\r\n      this.Session = dataAuthenticate.Session;\r\n      return callback.customChallenge(challengeParameters);\r\n    }\r\n    if (challengeName === 'NEW_PASSWORD_REQUIRED') {\r\n      this.Session = dataAuthenticate.Session;\r\n      var userAttributes = null;\r\n      var rawRequiredAttributes = null;\r\n      var requiredAttributes = [];\r\n      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\r\n      if (challengeParameters) {\r\n        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);\r\n        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);\r\n      }\r\n      if (rawRequiredAttributes) {\r\n        for (var i = 0; i < rawRequiredAttributes.length; i++) {\r\n          requiredAttributes[i] = rawRequiredAttributes[i].substr(userAttributesPrefix.length);\r\n        }\r\n      }\r\n      return callback.newPasswordRequired(userAttributes, requiredAttributes);\r\n    }\r\n    if (challengeName === 'DEVICE_SRP_AUTH') {\r\n      this.Session = dataAuthenticate.Session;\r\n      this.getDeviceResponse(callback);\r\n      return undefined;\r\n    }\r\n    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\r\n    this.challengeName = challengeName;\r\n    this.cacheTokens();\r\n    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;\r\n    if (newDeviceMetadata == null) {\r\n      return callback.onSuccess(this.signInUserSession);\r\n    }\r\n    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\r\n      if (errGenHash) {\r\n        return callback.onFailure(errGenHash);\r\n      }\r\n      var deviceSecretVerifierConfig = {\r\n        Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\r\n        PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\r\n      };\r\n      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\r\n      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;\r\n      _this4.randomPassword = authenticationHelper.getRandomPassword();\r\n      _this4.client.request('ConfirmDevice', {\r\n        DeviceKey: newDeviceMetadata.DeviceKey,\r\n        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),\r\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\r\n        DeviceName: userAgent\r\n      }, function (errConfirm, dataConfirm) {\r\n        if (errConfirm) {\r\n          return callback.onFailure(errConfirm);\r\n        }\r\n        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\r\n        _this4.cacheDeviceKeyAndPassword();\r\n        if (dataConfirm.UserConfirmationNecessary === true) {\r\n          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);\r\n        }\r\n        return callback.onSuccess(_this4.signInUserSession);\r\n      });\r\n      return undefined;\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This method is user to complete the NEW_PASSWORD_REQUIRED challenge.\r\n   * Pass the new password with any new user attributes to be updated.\r\n   * User attribute keys must be of format userAttributes.<attribute_name>.\r\n   * @param {string} newPassword new password for this user\r\n   * @param {object} requiredAttributeData map with values for all required attributes\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {mfaRequired} callback.mfaRequired MFA code required to continue.\r\n   * @param {customChallenge} callback.customChallenge Custom challenge\r\n   *         response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {\r\n    var _this5 = this;\r\n    if (!newPassword) {\r\n      return callback.onFailure(new Error('New password is required.'));\r\n    }\r\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\r\n    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();\r\n    var finalUserAttributes = {};\r\n    if (requiredAttributeData) {\r\n      Object.keys(requiredAttributeData).forEach(function (key) {\r\n        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];\r\n      });\r\n    }\r\n    finalUserAttributes.NEW_PASSWORD = newPassword;\r\n    finalUserAttributes.USERNAME = this.username;\r\n    var jsonReq = {\r\n      ChallengeName: 'NEW_PASSWORD_REQUIRED',\r\n      ClientId: this.pool.getClientId(),\r\n      ChallengeResponses: finalUserAttributes,\r\n      Session: this.Session,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('RespondToAuthChallenge', jsonReq, function (errAuthenticate, dataAuthenticate) {\r\n      if (errAuthenticate) {\r\n        return callback.onFailure(errAuthenticate);\r\n      }\r\n      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to get a session using device authentication. It is called at the end of user\r\n   * authentication\r\n   *\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   * @private\r\n   */;\r\n  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {\r\n    var _this6 = this;\r\n    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);\r\n    var dateHelper = new DateHelper();\r\n    var authParameters = {};\r\n    authParameters.USERNAME = this.username;\r\n    authParameters.DEVICE_KEY = this.deviceKey;\r\n    authenticationHelper.getLargeAValue(function (errAValue, aValue) {\r\n      // getLargeAValue callback start\r\n      if (errAValue) {\r\n        callback.onFailure(errAValue);\r\n      }\r\n      authParameters.SRP_A = aValue.toString(16);\r\n      var jsonReq = {\r\n        ChallengeName: 'DEVICE_SRP_AUTH',\r\n        ClientId: _this6.pool.getClientId(),\r\n        ChallengeResponses: authParameters,\r\n        ClientMetadata: clientMetadata,\r\n        Session: _this6.Session\r\n      };\r\n      if (_this6.getUserContextData()) {\r\n        jsonReq.UserContextData = _this6.getUserContextData();\r\n      }\r\n      _this6.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        var challengeParameters = data.ChallengeParameters;\r\n        var serverBValue = new BigInteger(challengeParameters.SRP_B, 16);\r\n        var salt = new BigInteger(challengeParameters.SALT, 16);\r\n        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function (errHkdf, hkdf) {\r\n          // getPasswordAuthenticationKey callback start\r\n          if (errHkdf) {\r\n            return callback.onFailure(errHkdf);\r\n          }\r\n          var dateNow = dateHelper.getNowString();\r\n          var concatBuffer = Buffer.concat([Buffer.from(_this6.deviceGroupKey, 'utf8'), Buffer.from(_this6.deviceKey, 'utf8'), Buffer.from(challengeParameters.SECRET_BLOCK, 'base64'), Buffer.from(dateNow, 'utf8')]);\r\n          var awsCryptoHash = new Sha256(hkdf);\r\n          awsCryptoHash.update(concatBuffer);\r\n          var resultFromAWSCrypto = awsCryptoHash.digestSync();\r\n          var signatureString = Buffer.from(resultFromAWSCrypto).toString('base64');\r\n          var challengeResponses = {};\r\n          challengeResponses.USERNAME = _this6.username;\r\n          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;\r\n          challengeResponses.TIMESTAMP = dateNow;\r\n          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;\r\n          challengeResponses.DEVICE_KEY = _this6.deviceKey;\r\n          var jsonReqResp = {\r\n            ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\r\n            ClientId: _this6.pool.getClientId(),\r\n            ChallengeResponses: challengeResponses,\r\n            Session: data.Session\r\n          };\r\n          if (_this6.getUserContextData()) {\r\n            jsonReqResp.UserContextData = _this6.getUserContextData();\r\n          }\r\n          _this6.client.request('RespondToAuthChallenge', jsonReqResp, function (errAuthenticate, dataAuthenticate) {\r\n            if (errAuthenticate) {\r\n              return callback.onFailure(errAuthenticate);\r\n            }\r\n            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\r\n            _this6.cacheTokens();\r\n            return callback.onSuccess(_this6.signInUserSession);\r\n          });\r\n          return undefined;\r\n          // getPasswordAuthenticationKey callback end\r\n        });\r\n\r\n        return undefined;\r\n      });\r\n      // getLargeAValue callback end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used for a certain user to confirm the registration by using a confirmation code\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {bool} forceAliasCreation Allow migrating from an existing email / phone number.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {\r\n    var jsonReq = {\r\n      ClientId: this.pool.getClientId(),\r\n      ConfirmationCode: confirmationCode,\r\n      Username: this.username,\r\n      ForceAliasCreation: forceAliasCreation,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('ConfirmSignUp', jsonReq, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used by the user once he has the responses to a custom challenge\r\n   * @param {string} answerChallenge The custom challenge answer.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {customChallenge} callback.customChallenge\r\n   *    Custom challenge response required to continue.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {\r\n    var _this7 = this;\r\n    var challengeResponses = {};\r\n    challengeResponses.USERNAME = this.username;\r\n    challengeResponses.ANSWER = answerChallenge;\r\n    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());\r\n    this.getCachedDeviceKeyAndPassword();\r\n    if (this.deviceKey != null) {\r\n      challengeResponses.DEVICE_KEY = this.deviceKey;\r\n    }\r\n    var jsonReq = {\r\n      ChallengeName: 'CUSTOM_CHALLENGE',\r\n      ChallengeResponses: challengeResponses,\r\n      ClientId: this.pool.getClientId(),\r\n      Session: this.Session,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return _this7.authenticateUserInternal(data, authenticationHelper, callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used by the user once he has an MFA code\r\n   * @param {string} confirmationCode The MFA code entered by the user.\r\n   * @param {object} callback Result callback map.\r\n   * @param {string} mfaType The mfa we are replying to.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {authSuccess} callback.onSuccess Called on success with the new session.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {\r\n    var _this8 = this;\r\n    var challengeResponses = {};\r\n    challengeResponses.USERNAME = this.username;\r\n    challengeResponses.SMS_MFA_CODE = confirmationCode;\r\n    var mfaTypeSelection = mfaType || 'SMS_MFA';\r\n    if (mfaTypeSelection === 'SOFTWARE_TOKEN_MFA') {\r\n      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;\r\n    }\r\n    if (this.deviceKey != null) {\r\n      challengeResponses.DEVICE_KEY = this.deviceKey;\r\n    }\r\n    var jsonReq = {\r\n      ChallengeName: mfaTypeSelection,\r\n      ChallengeResponses: challengeResponses,\r\n      ClientId: this.pool.getClientId(),\r\n      Session: this.Session,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, dataAuthenticate) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      var challengeName = dataAuthenticate.ChallengeName;\r\n      if (challengeName === 'DEVICE_SRP_AUTH') {\r\n        _this8.getDeviceResponse(callback);\r\n        return undefined;\r\n      }\r\n      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);\r\n      _this8.cacheTokens();\r\n      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {\r\n        return callback.onSuccess(_this8.signInUserSession);\r\n      }\r\n      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());\r\n      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function (errGenHash) {\r\n        if (errGenHash) {\r\n          return callback.onFailure(errGenHash);\r\n        }\r\n        var deviceSecretVerifierConfig = {\r\n          Salt: Buffer.from(authenticationHelper.getSaltDevices(), 'hex').toString('base64'),\r\n          PasswordVerifier: Buffer.from(authenticationHelper.getVerifierDevices(), 'hex').toString('base64')\r\n        };\r\n        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;\r\n        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;\r\n        _this8.randomPassword = authenticationHelper.getRandomPassword();\r\n        _this8.client.request('ConfirmDevice', {\r\n          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,\r\n          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),\r\n          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,\r\n          DeviceName: userAgent\r\n        }, function (errConfirm, dataConfirm) {\r\n          if (errConfirm) {\r\n            return callback.onFailure(errConfirm);\r\n          }\r\n          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;\r\n          _this8.cacheDeviceKeyAndPassword();\r\n          if (dataConfirm.UserConfirmationNecessary === true) {\r\n            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);\r\n          }\r\n          return callback.onSuccess(_this8.signInUserSession);\r\n        });\r\n        return undefined;\r\n      });\r\n      return undefined;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to change the current password\r\n   * @param {string} oldUserPassword The current password.\r\n   * @param {string} newUserPassword The requested new password.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('ChangePassword', {\r\n      PreviousPassword: oldUserPassword,\r\n      ProposedPassword: newUserPassword,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      ClientMetadata: clientMetadata\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to enable MFA for itself\r\n   * @deprecated\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.enableMFA = function enableMFA(callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    var mfaOptions = [];\r\n    var mfaEnabled = {\r\n      DeliveryMedium: 'SMS',\r\n      AttributeName: 'phone_number'\r\n    };\r\n    mfaOptions.push(mfaEnabled);\r\n    this.client.request('SetUserSettings', {\r\n      MFAOptions: mfaOptions,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to enable MFA for itself\r\n   * @param {IMfaSettings} smsMfaSettings the sms mfa settings\r\n   * @param {IMFASettings} softwareTokenMfaSettings the software token mfa settings\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('SetUserMFAPreference', {\r\n      SMSMfaSettings: smsMfaSettings,\r\n      SoftwareTokenMfaSettings: softwareTokenMfaSettings,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to disable MFA for itself\r\n   * @deprecated\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.disableMFA = function disableMFA(callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    var mfaOptions = [];\r\n    this.client.request('SetUserSettings', {\r\n      MFAOptions: mfaOptions,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to delete itself\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.deleteUser = function deleteUser(callback, clientMetadata) {\r\n    var _this9 = this;\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('DeleteUser', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      ClientMetadata: clientMetadata\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      _this9.clearCachedUser();\r\n      return callback(null, 'SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @typedef {CognitoUserAttribute | { Name:string, Value:string }} AttributeArg\r\n   */\r\n  /**\r\n   * This is used by an authenticated user to change a list of attributes\r\n   * @param {AttributeArg[]} attributes A list of the new user attributes.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {\r\n    var _this10 = this;\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('UpdateUserAttributes', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      UserAttributes: attributes,\r\n      ClientMetadata: clientMetadata\r\n    }, function (err, result) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n\r\n      // update cached user\r\n      return _this10.getUserData(function () {\r\n        return callback(null, 'SUCCESS', result);\r\n      }, {\r\n        bypassCache: true\r\n      });\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to get a list of attributes\r\n   * @param {nodeCallback<CognitoUserAttribute[]>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.getUserAttributes = function getUserAttributes(callback) {\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('GetUser', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err, userData) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      var attributeList = [];\r\n      for (var i = 0; i < userData.UserAttributes.length; i++) {\r\n        var attribute = {\r\n          Name: userData.UserAttributes[i].Name,\r\n          Value: userData.UserAttributes[i].Value\r\n        };\r\n        var userAttribute = new CognitoUserAttribute(attribute);\r\n        attributeList.push(userAttribute);\r\n      }\r\n      return callback(null, attributeList);\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This was previously used by an authenticated user to get MFAOptions,\r\n   * but no longer returns a meaningful response. Refer to the documentation for\r\n   * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\r\n   * @deprecated\r\n   * @param {nodeCallback<MFAOptions>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.getMFAOptions = function getMFAOptions(callback) {\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('GetUser', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err, userData) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, userData.MFAOptions);\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\r\n  _proto.createGetUserRequest = function createGetUserRequest() {\r\n    return this.client.promisifyRequest('GetUser', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\r\n  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {\r\n    var _this11 = this;\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n    // best effort, if not possible\r\n    return new Promise(function (resolve) {\r\n      var refresh = _this11.signInUserSession.getRefreshToken();\r\n      if (refresh && refresh.getToken()) {\r\n        _this11.refreshSession(refresh, resolve, options.clientMetadata);\r\n      } else {\r\n        resolve();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} GetUserDataOptions\r\n   * @property {boolean} bypassCache - force getting data from Cognito service\r\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\r\n   */\r\n\r\n  /**\r\n   * This is used by an authenticated users to get the userData\r\n   * @param {nodeCallback<UserData>} callback Called on success or error.\r\n   * @param {GetUserDataOptions} params\r\n   * @returns {void}\r\n   */;\r\n  _proto.getUserData = function getUserData(callback, params) {\r\n    var _this12 = this;\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      this.clearCachedUserData();\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    var userData = this.getUserDataFromCache();\r\n    if (!userData) {\r\n      this.fetchUserData().then(function (data) {\r\n        callback(null, data);\r\n      })[\"catch\"](callback);\r\n      return;\r\n    }\r\n    if (this.isFetchUserDataAndTokenRequired(params)) {\r\n      this.fetchUserData().then(function (data) {\r\n        return _this12.refreshSessionIfPossible(params).then(function () {\r\n          return data;\r\n        });\r\n      }).then(function (data) {\r\n        return callback(null, data);\r\n      })[\"catch\"](callback);\r\n      return;\r\n    }\r\n    try {\r\n      callback(null, JSON.parse(userData));\r\n      return;\r\n    } catch (err) {\r\n      this.clearCachedUserData();\r\n      callback(err, null);\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\r\n  _proto.getUserDataFromCache = function getUserDataFromCache() {\r\n    var userData = this.storage.getItem(this.userDataKey);\r\n    return userData;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\r\n  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {\r\n    var _ref = params || {},\r\n      _ref$bypassCache = _ref.bypassCache,\r\n      bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;\r\n    return bypassCache;\r\n  }\r\n  /**\r\n   *\r\n   * PRIVATE ONLY: This is an internal only method and should not\r\n   * be directly called by the consumers.\r\n   */;\r\n  _proto.fetchUserData = function fetchUserData() {\r\n    var _this13 = this;\r\n    return this.createGetUserRequest().then(function (data) {\r\n      _this13.cacheUserData(data);\r\n      return data;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated user to delete a list of attributes\r\n   * @param {string[]} attributeList Names of the attributes to delete.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {\r\n    var _this14 = this;\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      return callback(new Error('User is not authenticated'), null);\r\n    }\r\n    this.client.request('DeleteUserAttributes', {\r\n      UserAttributeNames: attributeList,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n\r\n      // update cached user\r\n      return _this14.getUserData(function () {\r\n        return callback(null, 'SUCCESS');\r\n      }, {\r\n        bypassCache: true\r\n      });\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used by a user to resend a confirmation code\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {\r\n    var jsonReq = {\r\n      ClientId: this.pool.getClientId(),\r\n      Username: this.username,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    this.client.request('ResendConfirmationCode', jsonReq, function (err, result) {\r\n      if (err) {\r\n        return callback(err, null);\r\n      }\r\n      return callback(null, result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} GetSessionOptions\r\n   * @property {Record<string, string>} clientMetadata - clientMetadata for getSession\r\n   */\r\n\r\n  /**\r\n   * This is used to get a session, either from the session object\r\n   * or from  the local storage, or by using a refresh token\r\n   *\r\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\r\n   * @param {GetSessionOptions} options\r\n   * @returns {void}\r\n   */;\r\n  _proto.getSession = function getSession(callback, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n    if (this.username == null) {\r\n      return callback(new Error('Username is null. Cannot retrieve a new session'), null);\r\n    }\r\n    if (this.signInUserSession != null && this.signInUserSession.isValid()) {\r\n      return callback(null, this.signInUserSession);\r\n    }\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\r\n    var idTokenKey = keyPrefix + \".idToken\";\r\n    var accessTokenKey = keyPrefix + \".accessToken\";\r\n    var refreshTokenKey = keyPrefix + \".refreshToken\";\r\n    var clockDriftKey = keyPrefix + \".clockDrift\";\r\n    if (this.storage.getItem(idTokenKey)) {\r\n      var idToken = new CognitoIdToken({\r\n        IdToken: this.storage.getItem(idTokenKey)\r\n      });\r\n      var accessToken = new CognitoAccessToken({\r\n        AccessToken: this.storage.getItem(accessTokenKey)\r\n      });\r\n      var refreshToken = new CognitoRefreshToken({\r\n        RefreshToken: this.storage.getItem(refreshTokenKey)\r\n      });\r\n      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;\r\n      var sessionData = {\r\n        IdToken: idToken,\r\n        AccessToken: accessToken,\r\n        RefreshToken: refreshToken,\r\n        ClockDrift: clockDrift\r\n      };\r\n      var cachedSession = new CognitoUserSession(sessionData);\r\n      if (cachedSession.isValid()) {\r\n        this.signInUserSession = cachedSession;\r\n        return callback(null, this.signInUserSession);\r\n      }\r\n      if (!refreshToken.getToken()) {\r\n        return callback(new Error('Cannot retrieve a new session. Please authenticate.'), null);\r\n      }\r\n      this.refreshSession(refreshToken, callback, options.clientMetadata);\r\n    } else {\r\n      callback(new Error('Local storage is missing an ID Token, Please authenticate'), null);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This uses the refreshToken to retrieve a new session\r\n   * @param {CognitoRefreshToken} refreshToken A previous session's refresh token.\r\n   * @param {nodeCallback<CognitoUserSession>} callback Called on success or error.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {\r\n    var _this15 = this;\r\n    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;\r\n    var authParameters = {};\r\n    authParameters.REFRESH_TOKEN = refreshToken.getToken();\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\r\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\r\n    if (this.storage.getItem(lastUserKey)) {\r\n      this.username = this.storage.getItem(lastUserKey);\r\n      var deviceKeyKey = keyPrefix + \".\" + this.username + \".deviceKey\";\r\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\r\n      authParameters.DEVICE_KEY = this.deviceKey;\r\n    }\r\n    var jsonReq = {\r\n      ClientId: this.pool.getClientId(),\r\n      AuthFlow: 'REFRESH_TOKEN_AUTH',\r\n      AuthParameters: authParameters,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('InitiateAuth', jsonReq, function (err, authResult) {\r\n      if (err) {\r\n        if (err.code === 'NotAuthorizedException') {\r\n          _this15.clearCachedUser();\r\n        }\r\n        return wrappedCallback(err, null);\r\n      }\r\n      if (authResult) {\r\n        var authenticationResult = authResult.AuthenticationResult;\r\n        if (!Object.prototype.hasOwnProperty.call(authenticationResult, 'RefreshToken')) {\r\n          authenticationResult.RefreshToken = refreshToken.getToken();\r\n        }\r\n        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);\r\n        _this15.cacheTokens();\r\n        return wrappedCallback(null, _this15.signInUserSession);\r\n      }\r\n      return undefined;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used to save the session tokens to local storage\r\n   * @returns {void}\r\n   */;\r\n  _proto.cacheTokens = function cacheTokens() {\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\r\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\r\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\r\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\r\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\r\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\r\n    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());\r\n    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());\r\n    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());\r\n    this.storage.setItem(clockDriftKey, \"\" + this.signInUserSession.getClockDrift());\r\n    this.storage.setItem(lastUserKey, this.username);\r\n  }\r\n\r\n  /**\r\n   * This is to cache user data\r\n   */;\r\n  _proto.cacheUserData = function cacheUserData(userData) {\r\n    this.storage.setItem(this.userDataKey, JSON.stringify(userData));\r\n  }\r\n\r\n  /**\r\n   * This is to remove cached user data\r\n   */;\r\n  _proto.clearCachedUserData = function clearCachedUserData() {\r\n    this.storage.removeItem(this.userDataKey);\r\n  };\r\n  _proto.clearCachedUser = function clearCachedUser() {\r\n    this.clearCachedTokens();\r\n    this.clearCachedUserData();\r\n  }\r\n\r\n  /**\r\n   * This is used to cache the device key and device group and device password\r\n   * @returns {void}\r\n   */;\r\n  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\r\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\r\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\r\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\r\n    this.storage.setItem(deviceKeyKey, this.deviceKey);\r\n    this.storage.setItem(randomPasswordKey, this.randomPassword);\r\n    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);\r\n  }\r\n\r\n  /**\r\n   * This is used to get current device key and device group and device password\r\n   * @returns {void}\r\n   */;\r\n  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\r\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\r\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\r\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\r\n    if (this.storage.getItem(deviceKeyKey)) {\r\n      this.deviceKey = this.storage.getItem(deviceKeyKey);\r\n      this.randomPassword = this.storage.getItem(randomPasswordKey);\r\n      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is used to clear the device key info from local storage\r\n   * @returns {void}\r\n   */;\r\n  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId() + \".\" + this.username;\r\n    var deviceKeyKey = keyPrefix + \".deviceKey\";\r\n    var randomPasswordKey = keyPrefix + \".randomPasswordKey\";\r\n    var deviceGroupKeyKey = keyPrefix + \".deviceGroupKey\";\r\n    this.storage.removeItem(deviceKeyKey);\r\n    this.storage.removeItem(randomPasswordKey);\r\n    this.storage.removeItem(deviceGroupKeyKey);\r\n  }\r\n\r\n  /**\r\n   * This is used to clear the session tokens from local storage\r\n   * @returns {void}\r\n   */;\r\n  _proto.clearCachedTokens = function clearCachedTokens() {\r\n    var keyPrefix = \"CognitoIdentityServiceProvider.\" + this.pool.getClientId();\r\n    var idTokenKey = keyPrefix + \".\" + this.username + \".idToken\";\r\n    var accessTokenKey = keyPrefix + \".\" + this.username + \".accessToken\";\r\n    var refreshTokenKey = keyPrefix + \".\" + this.username + \".refreshToken\";\r\n    var lastUserKey = keyPrefix + \".LastAuthUser\";\r\n    var clockDriftKey = keyPrefix + \".\" + this.username + \".clockDrift\";\r\n    this.storage.removeItem(idTokenKey);\r\n    this.storage.removeItem(accessTokenKey);\r\n    this.storage.removeItem(refreshTokenKey);\r\n    this.storage.removeItem(lastUserKey);\r\n    this.storage.removeItem(clockDriftKey);\r\n  }\r\n\r\n  /**\r\n   * This is used to build a user session from tokens retrieved in the authentication result\r\n   * @param {object} authResult Successful auth response from server.\r\n   * @returns {CognitoUserSession} The new user session.\r\n   * @private\r\n   */;\r\n  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {\r\n    var idToken = new CognitoIdToken(authResult);\r\n    var accessToken = new CognitoAccessToken(authResult);\r\n    var refreshToken = new CognitoRefreshToken(authResult);\r\n    var sessionData = {\r\n      IdToken: idToken,\r\n      AccessToken: accessToken,\r\n      RefreshToken: refreshToken\r\n    };\r\n    return new CognitoUserSession(sessionData);\r\n  }\r\n\r\n  /**\r\n   * This is used to initiate a forgot password request\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {inputVerificationCode?} callback.inputVerificationCode\r\n   *    Optional callback raised instead of onSuccess with response data.\r\n   * @param {onSuccess} callback.onSuccess Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {\r\n    var jsonReq = {\r\n      ClientId: this.pool.getClientId(),\r\n      Username: this.username,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('ForgotPassword', jsonReq, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      if (typeof callback.inputVerificationCode === 'function') {\r\n        return callback.inputVerificationCode(data);\r\n      }\r\n      return callback.onSuccess(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used to confirm a new password using a confirmationCode\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {string} newPassword Confirm new password.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<void>} callback.onSuccess Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {\r\n    var jsonReq = {\r\n      ClientId: this.pool.getClientId(),\r\n      Username: this.username,\r\n      ConfirmationCode: confirmationCode,\r\n      Password: newPassword,\r\n      ClientMetadata: clientMetadata\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('ConfirmForgotPassword', jsonReq, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used to initiate an attribute confirmation request\r\n   * @param {string} attributeName User attribute that needs confirmation.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {inputVerificationCode} callback.inputVerificationCode Called on success.\r\n   * @param {ClientMetadata} clientMetadata object which is passed from client to Cognito Lambda trigger\r\n   * @returns {void}\r\n   */;\r\n  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('GetUserAttributeVerificationCode', {\r\n      AttributeName: attributeName,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      ClientMetadata: clientMetadata\r\n    }, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      if (typeof callback.inputVerificationCode === 'function') {\r\n        return callback.inputVerificationCode(data);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to confirm an attribute using a confirmation code\r\n   * @param {string} attributeName Attribute being confirmed.\r\n   * @param {string} confirmationCode Code entered by user.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('VerifyUserAttribute', {\r\n      AttributeName: attributeName,\r\n      Code: confirmationCode,\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to get the device information using the current device key\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device data.\r\n   * @returns {void}\r\n   */;\r\n  _proto.getDevice = function getDevice(callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('GetDevice', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      DeviceKey: this.deviceKey\r\n    }, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess(data);\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to forget a specific device\r\n   * @param {string} deviceKey Device key.\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('ForgetDevice', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      DeviceKey: deviceKey\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to forget the current device\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.forgetDevice = function forgetDevice(callback) {\r\n    var _this16 = this;\r\n    this.forgetSpecificDevice(this.deviceKey, {\r\n      onFailure: callback.onFailure,\r\n      onSuccess: function onSuccess(result) {\r\n        _this16.deviceKey = null;\r\n        _this16.deviceGroupKey = null;\r\n        _this16.randomPassword = null;\r\n        _this16.clearCachedDeviceKeyAndPassword();\r\n        return callback.onSuccess(result);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used to set the device status as remembered\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('UpdateDeviceStatus', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      DeviceKey: this.deviceKey,\r\n      DeviceRememberedStatus: 'remembered'\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to set the device status as not remembered\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('UpdateDeviceStatus', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      DeviceKey: this.deviceKey,\r\n      DeviceRememberedStatus: 'not_remembered'\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to list all devices for a user\r\n   *\r\n   * @param {int} limit the number of devices returned in a call\r\n   * @param {string | null} paginationToken the pagination token in case any was returned before\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<*>} callback.onSuccess Called on success with device list.\r\n   * @returns {void}\r\n   */;\r\n  _proto.listDevices = function listDevices(limit, paginationToken, callback) {\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    var requestParams = {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n      Limit: limit\r\n    };\r\n    if (paginationToken) {\r\n      requestParams.PaginationToken = paginationToken;\r\n    }\r\n    this.client.request('ListDevices', requestParams, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      return callback.onSuccess(data);\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used to globally revoke all tokens issued to a user\r\n   * @param {object} callback Result callback map.\r\n   * @param {onFailure} callback.onFailure Called on any error.\r\n   * @param {onSuccess<string>} callback.onSuccess Called on success.\r\n   * @returns {void}\r\n   */;\r\n  _proto.globalSignOut = function globalSignOut(callback) {\r\n    var _this17 = this;\r\n    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {\r\n      return callback.onFailure(new Error('User is not authenticated'));\r\n    }\r\n    this.client.request('GlobalSignOut', {\r\n      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      _this17.clearCachedUser();\r\n      return callback.onSuccess('SUCCESS');\r\n    });\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used for the user to signOut of the application and clear the cached tokens.\r\n   * @returns {void}\r\n   */;\r\n  _proto.signOut = function signOut(revokeTokenCallback) {\r\n    var _this18 = this;\r\n    // If tokens won't be revoked, we just clean the client data.\r\n    if (!revokeTokenCallback || typeof revokeTokenCallback !== 'function') {\r\n      this.cleanClientData();\r\n      return;\r\n    }\r\n    this.getSession(function (error, _session) {\r\n      if (error) {\r\n        return revokeTokenCallback(error);\r\n      }\r\n      _this18.revokeTokens(function (err) {\r\n        _this18.cleanClientData();\r\n        revokeTokenCallback(err);\r\n      });\r\n    });\r\n  };\r\n  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {\r\n    if (revokeTokenCallback === void 0) {\r\n      revokeTokenCallback = function revokeTokenCallback() {};\r\n    }\r\n    if (typeof revokeTokenCallback !== 'function') {\r\n      throw new Error('Invalid revokeTokenCallback. It should be a function.');\r\n    }\r\n    var tokensToBeRevoked = [];\r\n    if (!this.signInUserSession) {\r\n      var error = new Error('User is not authenticated');\r\n      return revokeTokenCallback(error);\r\n    }\r\n    if (!this.signInUserSession.getAccessToken()) {\r\n      var _error = new Error('No Access token available');\r\n      return revokeTokenCallback(_error);\r\n    }\r\n    var refreshToken = this.signInUserSession.getRefreshToken().getToken();\r\n    var accessToken = this.signInUserSession.getAccessToken();\r\n    if (this.isSessionRevocable(accessToken)) {\r\n      if (refreshToken) {\r\n        return this.revokeToken({\r\n          token: refreshToken,\r\n          callback: revokeTokenCallback\r\n        });\r\n      }\r\n    }\r\n    revokeTokenCallback();\r\n  };\r\n  _proto.isSessionRevocable = function isSessionRevocable(token) {\r\n    if (token && typeof token.decodePayload === 'function') {\r\n      try {\r\n        var _token$decodePayload = token.decodePayload(),\r\n          origin_jti = _token$decodePayload.origin_jti;\r\n        return !!origin_jti;\r\n      } catch (err) {\r\n        // Nothing to do, token doesnt have origin_jti claim\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n  _proto.cleanClientData = function cleanClientData() {\r\n    this.signInUserSession = null;\r\n    this.clearCachedUser();\r\n  };\r\n  _proto.revokeToken = function revokeToken(_ref2) {\r\n    var token = _ref2.token,\r\n      callback = _ref2.callback;\r\n    this.client.requestWithRetry('RevokeToken', {\r\n      Token: token,\r\n      ClientId: this.pool.getClientId()\r\n    }, function (err) {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n      callback();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This is used by a user trying to select a given MFA\r\n   * @param {string} answerChallenge the mfa the user wants\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {\r\n    var _this19 = this;\r\n    var challengeResponses = {};\r\n    challengeResponses.USERNAME = this.username;\r\n    challengeResponses.ANSWER = answerChallenge;\r\n    var jsonReq = {\r\n      ChallengeName: 'SELECT_MFA_TYPE',\r\n      ChallengeResponses: challengeResponses,\r\n      ClientId: this.pool.getClientId(),\r\n      Session: this.Session\r\n    };\r\n    if (this.getUserContextData()) {\r\n      jsonReq.UserContextData = this.getUserContextData();\r\n    }\r\n    this.client.request('RespondToAuthChallenge', jsonReq, function (err, data) {\r\n      if (err) {\r\n        return callback.onFailure(err);\r\n      }\r\n      _this19.Session = data.Session;\r\n      if (answerChallenge === 'SMS_MFA') {\r\n        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);\r\n      }\r\n      if (answerChallenge === 'SOFTWARE_TOKEN_MFA') {\r\n        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);\r\n      }\r\n      return undefined;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This returns the user context data for advanced security feature.\r\n   * @returns {string} the user context data from CognitoUserPool\r\n   */;\r\n  _proto.getUserContextData = function getUserContextData() {\r\n    var pool = this.pool;\r\n    return pool.getUserContextData(this.username);\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated or a user trying to authenticate to associate a TOTP MFA\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {\r\n    var _this20 = this;\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      this.client.request('AssociateSoftwareToken', {\r\n        Session: this.Session\r\n      }, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        _this20.Session = data.Session;\r\n        return callback.associateSecretCode(data.SecretCode);\r\n      });\r\n    } else {\r\n      this.client.request('AssociateSoftwareToken', {\r\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()\r\n      }, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        return callback.associateSecretCode(data.SecretCode);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is used by an authenticated or a user trying to authenticate to verify a TOTP MFA\r\n   * @param {string} totpCode The MFA code entered by the user.\r\n   * @param {string} friendlyDeviceName The device name we are assigning to the device.\r\n   * @param {nodeCallback<string>} callback Called on success or error.\r\n   * @returns {void}\r\n   */;\r\n  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {\r\n    var _this21 = this;\r\n    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {\r\n      this.client.request('VerifySoftwareToken', {\r\n        Session: this.Session,\r\n        UserCode: totpCode,\r\n        FriendlyDeviceName: friendlyDeviceName\r\n      }, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        _this21.Session = data.Session;\r\n        var challengeResponses = {};\r\n        challengeResponses.USERNAME = _this21.username;\r\n        var jsonReq = {\r\n          ChallengeName: 'MFA_SETUP',\r\n          ClientId: _this21.pool.getClientId(),\r\n          ChallengeResponses: challengeResponses,\r\n          Session: _this21.Session\r\n        };\r\n        if (_this21.getUserContextData()) {\r\n          jsonReq.UserContextData = _this21.getUserContextData();\r\n        }\r\n        _this21.client.request('RespondToAuthChallenge', jsonReq, function (errRespond, dataRespond) {\r\n          if (errRespond) {\r\n            return callback.onFailure(errRespond);\r\n          }\r\n          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);\r\n          _this21.cacheTokens();\r\n          return callback.onSuccess(_this21.signInUserSession);\r\n        });\r\n        return undefined;\r\n      });\r\n    } else {\r\n      this.client.request('VerifySoftwareToken', {\r\n        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),\r\n        UserCode: totpCode,\r\n        FriendlyDeviceName: friendlyDeviceName\r\n      }, function (err, data) {\r\n        if (err) {\r\n          return callback.onFailure(err);\r\n        }\r\n        return callback.onSuccess(data);\r\n      });\r\n    }\r\n  };\r\n  return CognitoUser;\r\n}();\r\nexport { CognitoUser as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}